! GIDLAS mapping script

let SIC%TEE .TRUE.

let name &1
define image f 'name'.uvfit read /global
define header UVT_HEADER 'name'.uvfit read

IF (.NOT.EXIST(ilength)) define integer ilength
IF (.NOT.EXIST(nlength)) define integer nlength
nlength = f%dim[2]-4
if (mod(nlength,15).eq.0) then
  ilength = 15 ! Old uvfit format
else if (mod(nlength,17).eq.0) then
  ilength = 17 ! New uvfit format
endif

IF (.NOT.EXIST(nchan)) define integer nchan
let nchan f%dim[1]
say nchan = 'nchan'

IF (.NOT.EXIST(nobj)) define integer nobj
let nobj nlength/ilength


IF (.NOT.EXIST(rf_2)) define real rf_2
IF (.NOT.EXIST(rf_7)) define real rf_7
IF (.NOT.EXIST(rf_func_num)) define integer rf_func_num
IF (.NOT.EXIST(rf_x)) define real rf_x
IF (.NOT.EXIST(rf_x_err)) define real rf_x_err
IF (.NOT.EXIST(rf_y)) define real rf_y
IF (.NOT.EXIST(rf_y_err)) define real rf_y_err
IF (.NOT.EXIST(rf_freq)) define real rf_freq
IF (.NOT.EXIST(rf_flux)) define real rf_flux
IF (.NOT.EXIST(rf_flux_err)) define real rf_flux_err
IF (.NOT.EXIST(rf_major)) define real rf_major
IF (.NOT.EXIST(rf_major_err)) define real rf_major_err
IF (.NOT.EXIST(rf_minor)) define real rf_minor
IF (.NOT.EXIST(rf_minor_err)) define real rf_minor_err
IF (.NOT.EXIST(rf_PA)) define real rf_PA
IF (.NOT.EXIST(rf_PA_err)) define real rf_PA_err
IF (.NOT.EXIST(rf_snr)) define real rf_snr
IF (.NOT.EXIST(rf_ra)) define real rf_ra
IF (.NOT.EXIST(rf_dec)) define real rf_dec
IF (.NOT.EXIST(rf_velo)) define real rf_velo
!IF (.NOT.EXIST(rf_ra_hms)) define character*16 rf_ra_hms /global
!IF (.NOT.EXIST(rf_dec_dms)) define character*16 rf_dec_dms /global
IF (.NOT.EXIST(rf_width)) define real rf_width
let rf_func_num 0 ! number of functions, initialize it to 0
for iobj 1 to nobj
  !sic output "run_pdbi_uvt_go_uvfit_print_results.20250909.16h23m22s.CST.out" append
  !say 'name'".result.obj_"'iobj'".txt"
  !sic output
  !sic output 'name'".result.obj_"'iobj'".txt" new
  sic output 'name'".result.txt" new
  say # "freq" " " "flux" " " "flux_err" " " "SNR" " " "major" " " "major_err" " " "minor" " " "minor_err" " " "PA" " " "PA_err" " " "RA" " " "Dec" " " "velocity" " " "velwidth" /format A1 A12 A1 A15 A1 A15 A1 A12 A1 A12 A1 A12 A1 A12 A1 A12 A1 A12 A1 A12 A1 A15 A1 A15 A1 A12 A1 A12
  say # GHz " " mJy " " mJy " " "---" " " arcsec " " arcsec " " arcsec " " arcsec " " degree " " degree " " degree " " degree " " "km/s" " " "km/s" /format A1 A12 A1 A15 A1 A15 A1 A12 A1 A12 A1 A12 A1 A12 A1 A12 A1 A12 A1 A12 A1 A15 A1 A15 A1 A12 A1 A12
  for ichan 1 to nchan
    let rf_width    'abs(UVT_HEADER%VELRES)'
    let rf_velo      f[ichan,4]
    let rf_freq    -(rf_velo-f%veloff)*f%restfre/299792.458+f%restfre
    let rf_freq      rf_freq/1e3   ! to GHz
	let rf_2         f[ichan,'02+(iobj-1)*ilength']
	let rf_7         f[ichan,'07+(iobj-1)*ilength']
    let rf_x         f[ichan,'08+(iobj-1)*ilength']
    let rf_x_err     f[ichan,'09+(iobj-1)*ilength']
    let rf_y         f[ichan,'10+(iobj-1)*ilength']
    let rf_y_err     f[ichan,'11+(iobj-1)*ilength']
    let rf_flux      f[ichan,'12+(iobj-1)*ilength']
    let rf_flux_err  f[ichan,'13+(iobj-1)*ilength']
    let rf_flux      rf_flux*1e3        ! to mJy
    let rf_flux_err  rf_flux_err*1e3    ! to mJy
    let rf_snr       rf_flux/rf_flux_err
    if (rf_snr.LT.0) let rf_snr 0
    if (rf_func_num.EQ.0.AND.rf_2.GT.0.AND.rf_2.LE.100.AND.rf_7.GE.0.AND.rf_7.LE.10) let rf_func_num INT(rf_2) ! number of functions, only valid when rf_2<=100 and rf_7<=10
    if (rf_func_num.GT.0.AND.rf_7.GE.4) then
    let rf_major     f[ichan,'14+(iobj-1)*ilength']
    let rf_major_err f[ichan,'15+(iobj-1)*ilength']
    if (rf_major.LE.1E-7)     let rf_major 0
    if (rf_major.GE.1E+7)     let rf_major 0
    if (rf_major_err.LE.1E-7) let rf_major_err 0
    if (rf_major_err.GE.1E+7) let rf_major_err 0
    else
    let rf_major     0.0
    let rf_major_err -99
    endif
    if (rf_func_num.GT.0.AND.rf_7.GE.5) then
    let rf_minor     f[ichan,'16+(iobj-1)*ilength']
    let rf_minor_err f[ichan,'17+(iobj-1)*ilength']
    if (rf_minor.LE.1E-7)     let rf_minor 0
    if (rf_minor.GE.1E+7)     let rf_minor 0
    if (rf_minor_err.LE.1E-7) let rf_minor_err 0
    if (rf_minor_err.GE.1E+7) let rf_minor_err 0
    else
    let rf_minor     0.0
    let rf_minor_err -99
    endif
    if (rf_func_num.GT.0.AND.rf_7.GE.6) then
    let rf_PA        f[ichan,'18+(iobj-1)*ilength']
    let rf_PA_err    f[ichan,'19+(iobj-1)*ilength']
    if (rf_PA.LE.-1E+7)       let rf_PA 0
    if (rf_PA.GE.1E+7)        let rf_PA 0
    if (rf_PA_err.LE.-1E+7)   let rf_PA_err 0
    if (rf_PA_err.GE.1E+7)    let rf_PA_err 0
    else
    let rf_PA        0.0
    let rf_PA_err    -99
    endif
    if (rf_func_num.LE.0) then
    let rf_x 0.0
    let rf_y 0.0
    let rf_x_err -99
    let rf_y_err -99
    let rf_flux 0.0
    let rf_flux_err -99
    endif
    if (rf_func_num.GT.0.OR.1.EQ.1) then
      if (rf_x.LE.-1E+7.OR.rf_x.GE.+1E+7.OR.rf_y.LE.-1E+7.OR.rf_y.GE.+1E+7) then
        let rf_ra -99
        let rf_dec -99
        let rf_ra_hms "-99:-99:-99"
        let rf_dec_dms "-99:-99:-99"
        say rf_freq " " rf_flux " " rf_flux_err " " rf_snr " " rf_major " " rf_major_err " " rf_minor " " rf_minor_err " " rf_PA " " rf_PA_err " " rf_ra " " rf_dec " " rf_ra_hms " " rf_dec_dms " " rf_velo " " rf_width /format F12.6 A1 ES15.5 A1 ES15.5 A1 F12.1 A1 F12.4 A1 F12.4 A1 F12.4 A1 F12.4 A1 F12.4 A1 F12.4 A1 F15.7 A1 F15.7 A1 A16 A1 A16 A1 F12.4 A1 F12.4
      else
        if (f%a0.GT.0) then
          let rf_ra f%a0/pi*180+rf_x/3600/cos(f%d0)
          let rf_dec f%d0/pi*180+rf_y/3600
        else
          let rf_ra f%ra/pi*180+rf_x/3600/cos(f%dec)
          let rf_dec f%dec/pi*180+rf_y/3600
        endif
!        @ l-rad2ra.map rf_ra_hms 'rf_ra/180.0*pi'
!        @ l-rad2dec.map rf_dec_dms 'rf_dec/180.0*pi'
        say rf_freq " " rf_flux " " rf_flux_err " " rf_snr " " rf_major " " rf_major_err " " rf_minor " " rf_minor_err " " rf_PA " " rf_PA_err " " rf_ra " " rf_dec " " rf_velo " " rf_width /format F12.6 A1 ES15.5 A1 ES15.5 A1 F12.1 A1 F12.4 A1 F12.4 A1 F12.4 A1 F12.4 A1 F12.4 A1 F12.4 A1 F15.7 A1 F15.7 A1 F12.4 A1 F12.4
      endif
    endif
  next ichan
  sic output
next iobj



delete /variable f

